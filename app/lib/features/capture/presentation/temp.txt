class CapturePageState extends State<CapturePage>
    with
        AutomaticKeepAliveClientMixin,
        WidgetsBindingObserver,
        PhoneRecorderMixin,
        WebSocketMixin,
        OpenGlassMixin {
  final ScrollController _scrollController = ScrollController();
  @override
  bool get wantKeepAlive => true;

  BTDeviceStruct? btDevice;
  bool _hasTranscripts = false;
  static const quietSecondsForMemoryCreation = 60;

  List<TranscriptSegment> segments = [];
  StreamSubscription? _bleBytesStream;
  WavBytesUtil? audioStorage;

  Timer? _memoryCreationTimer;
  bool memoryCreating = false;

  DateTime? currentTranscriptStartedAt;
  DateTime? currentTranscriptFinishedAt;

  InternetStatus? _internetStatus;
  late StreamSubscription<InternetStatus> _internetListener;
  bool isGlasses = false;
  String conversationId = const Uuid().v4();

  double? streamStartedAtSecond;
  DateTime? firstStreamReceivedAt;
  int? secondsMissedOnReconnect;

  Future<void> initiateWebSocketConnection(
      {BleAudioCodec? audioCodec, int? sampleRate}) async {
    try {
      BleAudioCodec codec = audioCodec ??
          (btDevice?.id == null
              ? BleAudioCodec.pcm8
              : await getAudioCodec(btDevice!.id));
      await initWebSocket(
        codec: codec,
        sampleRate: sampleRate,
        onConnectionSuccess: handleWebSocketSuccess,
        onConnectionFailed: (err) {
          debugPrint("WebSocket connection failed: $err");
        },
        onConnectionClosed: handleWebSocketClosed,
        onConnectionError: (err) {
          debugPrint("WebSocket error: $err");
        },
        onMessageReceived: handleMessageReceived,
      );
    } catch (e) {
      debugPrint("Error initiating WebSocket: $e");
    }
  }

  void handleWebSocketSuccess() {
    debugPrint("WebSocket connected successfully");
    if (segments.isNotEmpty) {
      debugPrint("Resetting stream state due to reconnection");
      streamStartedAtSecond = null;
      secondsMissedOnReconnect =
          DateTime.now().difference(firstStreamReceivedAt!).inSeconds;
    }
    setState(() {});
  }

  void handleWebSocketClosed(int? closeCode, String? closeReason) {
    debugPrint("WebSocket connection closed: $closeCode $closeReason");
    setState(() {});
  }

  void handleMessageReceived(List<TranscriptSegment> newSegments) {
    if (newSegments.isEmpty) return;

    if (segments.isEmpty) {
      debugPrint("First segment received: ${newSegments.last}");
      audioStorage?.removeFramesRange(
          fromSecond: 0, toSecond: newSegments[0].start.toInt());
      firstStreamReceivedAt = DateTime.now();
    }

    streamStartedAtSecond ??= newSegments[0].start;
    TranscriptSegment.combineSegments(
      segments,
      newSegments,
      toRemoveSeconds: streamStartedAtSecond ?? 0,
      toAddSeconds: secondsMissedOnReconnect ?? 0,
    );

    _triggerTranscriptEvent(newSegments);
    restartMemoryCreationTimer();

    currentTranscriptStartedAt ??= DateTime.now();
    currentTranscriptFinishedAt = DateTime.now();

    _autoScrollToBottom();
    setState(() {});
  }

  void _triggerTranscriptEvent(List<TranscriptSegment> newSegments) {
    triggerTranscriptSegmentReceivedEvents(newSegments, conversationId,
        sendMessageToChat: sendMessageToChat);
    SharedPreferencesUtil().transcriptSegments = segments;
    setHasTranscripts(true);
  }

  void restartMemoryCreationTimer() {
    _memoryCreationTimer?.cancel();
    _memoryCreationTimer = Timer(
        const Duration(seconds: quietSecondsForMemoryCreation),
        () => _createMemory());
  }

  void _autoScrollToBottom() {
    if (_scrollController.hasClients) {
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 100),
        curve: Curves.easeOut,
      );
    }
  }

  Future<void> _createMemory({bool forcedCreation = false}) async {
    if (memoryCreating) return;
    setState(() => memoryCreating = true);

    try {
      // Memory creation logic goes here
      Memory? memory = await processTranscriptContent(
        context,
        TranscriptSegment.segmentsAsString(segments),
        segments,
        null,
        startedAt: currentTranscriptStartedAt,
        finishedAt: currentTranscriptFinishedAt,
        geolocation: await LocationService().getGeolocationDetails(),
        photos: photos,
        sendMessageToChat: sendMessageToChat,
      );

      if (memory != null && !memory.discarded) {
        executeBackupWithUid();
        context.read<MemoryBloc>().add(DisplayedMemory(isNonDiscarded: true));
      }

      _clearTranscriptState();
      await widget.refreshMemories();
    } catch (e) {
      debugPrint("Error creating memory: $e");
    } finally {
      setState(() => memoryCreating = false);
    }
  }

  void _clearTranscriptState() {
    SharedPreferencesUtil().transcriptSegments = [];
    segments = [];
    audioStorage?.clearAudioBytes();
    setHasTranscripts(false);

    currentTranscriptStartedAt = null;
    currentTranscriptFinishedAt = null;

    streamStartedAtSecond = null;
    firstStreamReceivedAt = null;
    secondsMissedOnReconnect = null;

    conversationId = const Uuid().v4();
  }

  setHasTranscripts(bool hasTranscripts) {
    if (_hasTranscripts == hasTranscripts) return;
    setState(() => _hasTranscripts = hasTranscripts);
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    btDevice = widget.device;
    initiateWebSocketConnection();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _bleBytesStream?.cancel();
    _memoryCreationTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    super.build(context);
    return CaptureMemoryPage(
      context: context,
      hasTranscripts: _hasTranscripts,
      wsConnectionState: wsConnectionState,
      device: widget.device,
      internetStatus: _internetStatus,
      segments: segments,
      memoryCreating: memoryCreating,
      photos: photos,
      scrollController: _scrollController,
      onDismissmissedCaptureMemory: (direction) => _createMemory(),
    );
  }
}
